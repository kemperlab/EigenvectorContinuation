<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>eigenvectorcontinuation.hilbertspaces package &mdash; EigenvectorContinuation 0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> EigenvectorContinuation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">eigenvectorcontinuation.hilbertspaces package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-eigenvectorcontinuation.hilbertspaces.circuit_mimic_space">eigenvectorcontinuation.hilbertspaces.circuit_mimic_space module</a></li>
<li><a class="reference internal" href="#module-eigenvectorcontinuation.hilbertspaces.circuit_space">eigenvectorcontinuation.hilbertspaces.circuit_space module</a></li>
<li><a class="reference internal" href="#module-eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract">eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract module</a></li>
<li><a class="reference internal" href="#module-eigenvectorcontinuation.hilbertspaces.numpy_vector_space">eigenvectorcontinuation.hilbertspaces.numpy_vector_space module</a></li>
<li><a class="reference internal" href="#module-eigenvectorcontinuation.hilbertspaces.unitary_space">eigenvectorcontinuation.hilbertspaces.unitary_space module</a></li>
<li><a class="reference internal" href="#module-eigenvectorcontinuation.hilbertspaces">Module contents</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">EigenvectorContinuation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>eigenvectorcontinuation.hilbertspaces package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/source/eigenvectorcontinuation.hilbertspaces.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="eigenvectorcontinuation-hilbertspaces-package">
<h1>eigenvectorcontinuation.hilbertspaces package<a class="headerlink" href="#eigenvectorcontinuation-hilbertspaces-package" title="Permalink to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-eigenvectorcontinuation.hilbertspaces.circuit_mimic_space">
<span id="eigenvectorcontinuation-hilbertspaces-circuit-mimic-space-module"></span><h2>eigenvectorcontinuation.hilbertspaces.circuit_mimic_space module<a class="headerlink" href="#module-eigenvectorcontinuation.hilbertspaces.circuit_mimic_space" title="Permalink to this heading"></a></h2>
<p>Concrete implementation of HSA that mimics the algebra used in a quantum circuit</p>
<p>CircuitMimicSpace is a simplified linear algebra representation of the computations run on
quantum circuits. For a set of input training points, it defines the behavior for inner products
and expectation values in this space and uses that behavior to calculate the overlap matrix and
subspace hamiltonian for the given space. Does not use Qiskit (Please see CircuitSpace for the
Qiskit implementation).</p>
<p>NOT YET IMPLEMENTED</p>
</section>
<section id="module-eigenvectorcontinuation.hilbertspaces.circuit_space">
<span id="eigenvectorcontinuation-hilbertspaces-circuit-space-module"></span><h2>eigenvectorcontinuation.hilbertspaces.circuit_space module<a class="headerlink" href="#module-eigenvectorcontinuation.hilbertspaces.circuit_space" title="Permalink to this heading"></a></h2>
<p>Concrete implementation of HSA that stores and calculates products using the Qiskit library</p>
<p>CircuitSpace uses the Qiskit library to define the behavior for inner products and expectation
values for data represented as quatum circuits. For a set of input training points, it can use
these to calculate the overlap matrix and subspace hamiltonian for the given space.</p>
<p>NOT YET IMPLEMENTED</p>
</section>
<section id="module-eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract">
<span id="eigenvectorcontinuation-hilbertspaces-hilbert-space-abstract-module"></span><h2>eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract module<a class="headerlink" href="#module-eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract" title="Permalink to this heading"></a></h2>
<p>HilbertSpaceAbstract:   Abstract class used to outline how concrete Hilbert Spaces behave</p>
<p>Hilbert Spaces are used to create EigenvectorContinuer objects. They require an implementation of
an inner product and an expectation value, which are used to calculate the overlap matrix and
subspace hamiltonian of the system. Additionally, they require a method of determinig which vector
to select from a list of eigenvectors (usually these correspond to different energy levels in a
system).</p>
<p>SOON TO BE ADDED:
Support for non-ground-state eigenvector continuation</p>
<dl class="py class">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.</span></span><span class="sig-name descname"><span class="pre">HilbertSpaceAbstract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Defines behavior for objects to have a hamiltonian, inner product, expectation value, and
selected vector</p>
<blockquote>
<div><dl class="simple">
<dt>INPUT:</dt><dd><p>a set of training vectors</p>
</dd>
</dl>
</div></blockquote>
<dl class="py property">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.basis_vecs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">basis_vecs</span></span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.basis_vecs" title="Permalink to this definition"></a></dt>
<dd><p>I’m the current space’s basis vectors</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.calc_basis_vecs">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">calc_basis_vecs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.calc_basis_vecs" title="Permalink to this definition"></a></dt>
<dd><p>calculates the basis vectors to span the space</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the calculated basis vecs</p>
</dd>
</dl>
<p>should be implemented by concrete class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.calc_overlap_matrix">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">calc_overlap_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.calc_overlap_matrix" title="Permalink to this definition"></a></dt>
<dd><p>defines the overlap matrix for space given some set of spanning vecs (basis_vecs)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> – points to use as training points (optional depending on implementation)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the overlap matrix</p>
</dd>
</dl>
<p>should be implemented by concrete class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.calc_sub_ham">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">calc_sub_ham</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ham</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.calc_sub_ham" title="Permalink to this definition"></a></dt>
<dd><p>defines a subspace hamiltonian for space given a hamiltonian in the space and
a set of spanning vectors (basis_vecs)</p>
<p>NB: ham cannot be constructed using the same points used to calc basis_vecs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ham</strong> – the hamiltonian used to find the subspace of</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the subspace hamiltonian</p>
</dd>
</dl>
<p>should be implemented by concrete class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.expectation_value">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">expectation_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ham</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.expectation_value" title="Permalink to this definition"></a></dt>
<dd><p>defines expectation value calculation for space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec1</strong> – the first vector in the calculation</p></li>
<li><p><strong>ham</strong> – the hamiltonian in the calculation</p></li>
<li><p><strong>vec2</strong> – the second vector in the calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the expectation value</p>
</dd>
</dl>
<p>should be implemented by concrete class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.inner_product">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>defines inner product for space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec1</strong> – the first vector in the calculation</p></li>
<li><p><strong>vec2</strong> – the second vector in the calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the result of the inner product</p>
</dd>
</dl>
<p>should be implemented by concrete class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.select_vec">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">select_vec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evecs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.select_vec" title="Permalink to this definition"></a></dt>
<dd><p>defines which vector to select when chooosing from a set of evecs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>evecs</strong> – the set of evecs</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the selected vector</p>
</dd>
</dl>
<p>should be implemented by concrete class</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.training_points">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">training_points</span></span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract.training_points" title="Permalink to this definition"></a></dt>
<dd><p>I’m the current space’s set of training points</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-eigenvectorcontinuation.hilbertspaces.numpy_vector_space">
<span id="eigenvectorcontinuation-hilbertspaces-numpy-vector-space-module"></span><h2>eigenvectorcontinuation.hilbertspaces.numpy_vector_space module<a class="headerlink" href="#module-eigenvectorcontinuation.hilbertspaces.numpy_vector_space" title="Permalink to this heading"></a></h2>
<dl class="simple">
<dt>NumPyVectorSpace:       An example concrete implementation of HilbertSpaceAbstract in which</dt><dd><p>data is represented in the form of type np.ndarray</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">eigenvectorcontinuation.hilbertspaces.numpy_vector_space.</span></span><span class="sig-name descname"><span class="pre">NumPyVectorSpace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_qubits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract" title="eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract"><code class="xref py py-class docutils literal notranslate"><span class="pre">HilbertSpaceAbstract</span></code></a></p>
<p>defines Hilbert Space behavior for numpy arrays</p>
<p>contains inner class to help construct hamiltonian</p>
<dl class="py class">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.HamiltonianInitializer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HamiltonianInitializer</span></span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.HamiltonianInitializer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>initializes the hamiltonian</p>
<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.HamiltonianInitializer.calc_eigenpairs">
<span class="sig-name descname"><span class="pre">calc_eigenpairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ham</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.HamiltonianInitializer.calc_eigenpairs" title="Permalink to this definition"></a></dt>
<dd><p>calcs the eigenpairs for a given param_setinate in a system</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ham</strong> – the hamiltonian to get the eigenpairs from</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the eigenpairs as: evals, evecs</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.HamiltonianInitializer.many_kron">
<span class="sig-name descname"><span class="pre">many_kron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ops</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.HamiltonianInitializer.many_kron" title="Permalink to this definition"></a></dt>
<dd><p>produces Kronecker (Tensor) product from list of Pauli charaters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ops</strong> – the operations [as characters] to apply to a matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.HamiltonianInitializer.xxztype_hamiltonian">
<span class="sig-name descname"><span class="pre">xxztype_hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.HamiltonianInitializer.xxztype_hamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>produces the hamiltonian for a system where j_x = j_y and b_x = b_y</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param_set</strong> – the set of parameters: j_x, j_z, b_x, b_z</p></li>
<li><p><strong>n_qubits</strong> – the number of quibits</p></li>
<li><p><strong>pbc</strong> – periodic boundary condition wrap around logic boolean</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>hamiltonian of the system</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.calc_basis_vecs">
<span class="sig-name descname"><span class="pre">calc_basis_vecs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.calc_basis_vecs" title="Permalink to this definition"></a></dt>
<dd><p>calculates the basis vectors for the given space
creates a hamiltonian for each point, and determines eigenvecs for each hamiltonian</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the calculated basis vecs</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.calc_overlap_matrix">
<span class="sig-name descname"><span class="pre">calc_overlap_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.calc_overlap_matrix" title="Permalink to this definition"></a></dt>
<dd><p>defines the overlap matrix for a NumPyVectorSpace</p>
<p>if points are passed in, these become the new training points of the space
otherwise, the existing training points are used</p>
<p>For an overlap matrix S:
S[i,j] = inner_product(basis_vec_i, basis_vec_j)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> – points to use as training points (optional)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the calculated overlap matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.calc_sub_ham">
<span class="sig-name descname"><span class="pre">calc_sub_ham</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ham</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.calc_sub_ham" title="Permalink to this definition"></a></dt>
<dd><p>defines a subspace hamiltonian for space given a hamiltonian in the space and
a set of spanning vectors (basis_vecs)</p>
<p>NB: ham cannot be constructed using the same points used to calc basis_vecs</p>
<p>Subspace Ham[i,j] = expectation_value(basis_vec_i, ham, basis_vec_j)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ham</strong> – the hamiltonian used to find the subspace of</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the subspace hamiltonian</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.expectation_value">
<span class="sig-name descname"><span class="pre">expectation_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ham</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.expectation_value" title="Permalink to this definition"></a></dt>
<dd><p>defines expectation value calculation for numpy array space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec1</strong> – the left vector of the expectation value calculation</p></li>
<li><p><strong>ham</strong> – retrieve the expectation value w.r.t. this hamiltonian</p></li>
<li><p><strong>vec2</strong> – the right vector of the expectation value calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the expectation value of the system</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.implementation_type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">implementation_type</span></span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.implementation_type" title="Permalink to this definition"></a></dt>
<dd><p>I’m the current space’s implementation type</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>defines inner product for numpy array space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec1</strong> – the left vector of the inner product</p></li>
<li><p><strong>vec2</strong> – the right vector of the inner product</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>inner product of vec1 &amp; vec2</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.num_qubits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_qubits</span></span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.num_qubits" title="Permalink to this definition"></a></dt>
<dd><p>I’m the current space’s number of qubits</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.select_vec">
<span class="sig-name descname"><span class="pre">select_vec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evecs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.numpy_vector_space.NumPyVectorSpace.select_vec" title="Permalink to this definition"></a></dt>
<dd><p>returns the lowest energy evec</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>evecs</strong> – the set of evecs</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the selected vector</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-eigenvectorcontinuation.hilbertspaces.unitary_space">
<span id="eigenvectorcontinuation-hilbertspaces-unitary-space-module"></span><h2>eigenvectorcontinuation.hilbertspaces.unitary_space module<a class="headerlink" href="#module-eigenvectorcontinuation.hilbertspaces.unitary_space" title="Permalink to this heading"></a></h2>
<dl class="simple">
<dt>UnitarySpace:           An example concrete implementation of HSA in which vectors are</dt><dd><p>defined as their corresponding unitary matrices</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">eigenvectorcontinuation.hilbertspaces.unitary_space.</span></span><span class="sig-name descname"><span class="pre">UnitarySpace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_qubits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract" title="eigenvectorcontinuation.hilbertspaces.hilbert_space_abstract.HilbertSpaceAbstract"><code class="xref py py-class docutils literal notranslate"><span class="pre">HilbertSpaceAbstract</span></code></a></p>
<p>defines Hilbert Space behavior for unitary matrices stored as numpy arrays</p>
<p>contains inner class to help construct hamiltonian</p>
<dl class="py class">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.HamiltonianInitializer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HamiltonianInitializer</span></span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.HamiltonianInitializer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>initializes the hamiltonian</p>
<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.HamiltonianInitializer.calc_eigenpairs">
<span class="sig-name descname"><span class="pre">calc_eigenpairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ham</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.HamiltonianInitializer.calc_eigenpairs" title="Permalink to this definition"></a></dt>
<dd><p>calcs the eigenpairs for a given param_setinate in a system</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ham</strong> – the hamiltonian to get the eigenpairs from</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the eigenpairs as: evals, evecs</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.HamiltonianInitializer.many_kron">
<span class="sig-name descname"><span class="pre">many_kron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ops</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.HamiltonianInitializer.many_kron" title="Permalink to this definition"></a></dt>
<dd><p>produces Kronecker (Tensor) product from list of Pauli charaters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ops</strong> – the operations [as characters] to apply to a matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.HamiltonianInitializer.xxztype_hamiltonian">
<span class="sig-name descname"><span class="pre">xxztype_hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.HamiltonianInitializer.xxztype_hamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>produces the hamiltonian for a system where j_x = j_y and b_x = b_y</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param_set</strong> – the set of parameters: j_x, j_z, b_x, b_z</p></li>
<li><p><strong>n_qubits</strong> – the number of quibits</p></li>
<li><p><strong>pbc</strong> – periodic boundary condition wrap around logic boolean</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>hamiltonian of the system</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.calc_basis_vecs">
<span class="sig-name descname"><span class="pre">calc_basis_vecs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.calc_basis_vecs" title="Permalink to this definition"></a></dt>
<dd><p>calculates the basis vectors for the given space
creates a hamiltonian for each point, and determines eigenvecs for each hamiltonian</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the calculated basis vecs</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.calc_overlap_matrix">
<span class="sig-name descname"><span class="pre">calc_overlap_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.calc_overlap_matrix" title="Permalink to this definition"></a></dt>
<dd><p>defines the overlap matrix for a UnitarySpace</p>
<p>if points are passed in, these become the new training points of the space
otherwise, the existing training points are used</p>
<p>For an overlap matrix S:
S[i,j] = inner_product(unitary_i, unitary_j)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> – points to use as training points (optional)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the calculated overlap matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.calc_sub_ham">
<span class="sig-name descname"><span class="pre">calc_sub_ham</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ham</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.calc_sub_ham" title="Permalink to this definition"></a></dt>
<dd><p>defines a subspace hamiltonian for space given a hamiltonian in the space and
a set of spanning vectors (basis_vecs)</p>
<p>NB: ham cannot be constructed using the same points used to calc basis_vecs</p>
<p>Subspace Ham[i,j] = expectation_value(unitary_i, ham, unitary_j)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ham</strong> – the hamiltonian used to find the subspace of</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the subspace hamiltonian</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.calc_unitaries">
<span class="sig-name descname"><span class="pre">calc_unitaries</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.calc_unitaries" title="Permalink to this definition"></a></dt>
<dd><p>calculates the unitary for each vector in this instance’s basis_vecs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vecs</strong> – the vectors from which to calculate the unitaries</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the unitary matrix, one for each vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.calc_unitary">
<span class="sig-name descname"><span class="pre">calc_unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_vec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.calc_unitary" title="Permalink to this definition"></a></dt>
<dd><p>calculates the unitary for a given vector</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input_vec</strong> – the vector from which to calculate the unitary</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the unitary matrix for the vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.expectation_value">
<span class="sig-name descname"><span class="pre">expectation_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ham</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.expectation_value" title="Permalink to this definition"></a></dt>
<dd><p>defines expectation value calculation for numpy array space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec1</strong> – the left vector of the expectation value calculation</p></li>
<li><p><strong>ham</strong> – retrieve the expectation value w.r.t. this hamiltonian</p></li>
<li><p><strong>vec2</strong> – the right vector of the expectation value calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the expectation value of the system</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.implementation_type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">implementation_type</span></span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.implementation_type" title="Permalink to this definition"></a></dt>
<dd><p>I’m the current space’s implementation type</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>defines inner product for numpy array space. The vectors used as input are
assumed to be unitary matrices for this class</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec1</strong> – the left vector of the inner product</p></li>
<li><p><strong>vec2</strong> – the right vector of the inner product</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>inner product of vec1 &amp; vec2</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.num_qubits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_qubits</span></span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.num_qubits" title="Permalink to this definition"></a></dt>
<dd><p>I’m the current space’s number of qubits</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.select_vec">
<span class="sig-name descname"><span class="pre">select_vec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evecs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.select_vec" title="Permalink to this definition"></a></dt>
<dd><p>returns the lowest energy evec</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>evecs</strong> – the set of evecs</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the selected vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.unitaries">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">unitaries</span></span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.unitaries" title="Permalink to this definition"></a></dt>
<dd><p>I’m this space’s list of unitaries. Each unitary is calculated from a basis vector
(all basis vectors are calculated from the input training points)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.zero_bra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">zero_bra</span></span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.zero_bra" title="Permalink to this definition"></a></dt>
<dd><p>I’m this space’s zero_bra, to be used in many calculations. zero_bra is often
denoted as &lt;0| and is defined as the row vector: (1 0 0 … 0)  with length
2**num_qubits</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.zero_ket">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">zero_ket</span></span><a class="headerlink" href="#eigenvectorcontinuation.hilbertspaces.unitary_space.UnitarySpace.zero_ket" title="Permalink to this definition"></a></dt>
<dd><p>I’m this space’s zero_ket, to be used in many calculations. zero_ket is often
denoted as <a href="#id1"><span class="problematic" id="id2">|</span></a>0&gt; and is defined as the column vector: (1 0 0 … 0).T  with length
2**num_qubits</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-eigenvectorcontinuation.hilbertspaces">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-eigenvectorcontinuation.hilbertspaces" title="Permalink to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Copyright (c) 2022 Kemper Lab, Jack H. Howard, Akhil Francis, Alexander F. Kemper.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>